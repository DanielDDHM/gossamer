package trie

import (
	"slices"

	hashdb "github.com/ChainSafe/gossamer/internal/hash-db"
	"github.com/ChainSafe/gossamer/internal/hash-db/wrapper"
	memorydb "github.com/ChainSafe/gossamer/internal/memory-db"
	"github.com/ChainSafe/gossamer/internal/primitives/runtime"
	"github.com/ChainSafe/gossamer/internal/primitives/storage"
	"github.com/ChainSafe/gossamer/pkg/trie"
	"github.com/ChainSafe/gossamer/pkg/trie/cache"
	triedb "github.com/ChainSafe/gossamer/pkg/trie/triedb"
)

// / Reexport from `hash_db`, with genericity set for `Hasher` trait.
// / This uses a `KeyFunction` for prefixing keys internally (avoiding
// / key conflict for non random keys).
// pub type PrefixedMemoryDB<H> = memory_db::MemoryDB<H, memory_db::PrefixedKey<H>, trie_db::DBValue>;
type PrefixedMemoryDB[Hash runtime.Hash, Hasher hashdb.Hasher[Hash]] struct {
	memorydb.MemoryDB[Hash, Hasher, Hash, memorydb.PrefixedKey[Hash], []byte]
}

func NewPrefixedMemoryDB[Hash runtime.Hash, Hasher hashdb.Hasher[Hash]]() *PrefixedMemoryDB[Hash, Hasher] {
	return &PrefixedMemoryDB[Hash, Hasher]{
		memorydb.NewMemoryDB[Hash, Hasher, Hash, memorydb.PrefixedKey[Hash], []byte]([]byte{0}),
	}
}

// func (pmdb *PrefixedMemoryDB[Hash, Hasher]) Get(key Hash, prefix hashdb.Prefix) *[]byte {
// 	memdb := memorydb.MemoryDB[Hash, Hasher, Hash, memorydb.HashKey[Hash], []byte](*pmdb)
// 	return memdb.Get(key, prefix)
// }

// func (pmdb *PrefixedMemoryDB[Hash, Hasher]) Insert(prefix hashdb.Prefix, value []byte) Hash {
// 	memdb := memorydb.MemoryDB[Hash, Hasher, Hash, memorydb.HashKey[Hash], []byte](*pmdb)
// 	h := memdb.Insert(prefix, value)
// 	*pmdb = PrefixedMemoryDB[Hash, Hasher](memdb)
// 	return h
// }

// func (pmdb *PrefixedMemoryDB[Hash, Hasher]) Emplace(key Hash, prefix hashdb.Prefix, value []byte) {
// 	memdb := memorydb.MemoryDB[Hash, Hasher, Hash, memorydb.HashKey[Hash], []byte](*pmdb)
// 	memdb.Emplace(key, prefix, value)
// 	*pmdb = PrefixedMemoryDB[Hash, Hasher](memdb)
// }

// func (pmdb *PrefixedMemoryDB[Hash, Hasher]) Remove(key Hash, prefix hashdb.Prefix) {
// 	memdb := memorydb.MemoryDB[Hash, Hasher, Hash, memorydb.HashKey[Hash], []byte](*pmdb)
// 	memdb.Remove(key, prefix)
// 	*pmdb = PrefixedMemoryDB[Hash, Hasher](memdb)
// }

// / Reexport from `hash_db`, with genericity set for `Hasher` trait.
// / This uses a noops `KeyFunction` (key addressing must be hashed or using
// / an encoding scheme that avoid key conflict).
// pub type MemoryDB<H> = memory_db::MemoryDB<H, memory_db::HashKey<H>, trie_db::DBValue>;
type MemoryDB[Hash runtime.Hash, Hasher runtime.Hasher[Hash]] struct {
	memorydb.MemoryDB[Hash, Hasher, Hash, memorydb.HashKey[Hash], []byte]
}

func NewMemoryDB[Hash runtime.Hash, Hasher runtime.Hasher[Hash]]() *MemoryDB[Hash, Hasher] {
	return &MemoryDB[Hash, Hasher]{
		MemoryDB: memorydb.NewMemoryDB[Hash, Hasher, Hash, memorydb.HashKey[Hash], []byte]([]byte{0}),
	}
}

// pub type TrieHash<L> = <<L as TrieLayout>::Hash as Hasher>::Out;

// / Builder for creating a [`TrieDB`].
// pub type TrieDBBuilder<'a, 'cache, L> = trie_db::TrieDBBuilder<'a, 'cache, L>;
// type TrieDBBuilder[Hash, DB, Cache, Layout any] triedb.TrieDBBuilder[Hash, DB, Cache, Layout]

// / Verify a set of key-value pairs against a trie root and a proof.
// /
// / Checks a set of keys with optional values for inclusion in the proof that was generated by
// / `generate_trie_proof`.
// / If the value in the pair is supplied (`(key, Some(value))`), this key-value pair will be
// / checked for inclusion in the proof.
// / If the value is omitted (`(key, None)`), this key will be checked for non-inclusion in the
// / proof.
func VerifyTrieProof[TrieHash comparable](
	root TrieHash,
	proof [][]byte,
	items []struct {
		Key   []byte
		Value *[]byte
	},
) error {
	panic("unimpl")
}

// / Determine a trie root given a hash DB and delta values.
func DeltaTrieRoot[H runtime.Hash, Hasher runtime.Hasher[H]](
	db hashdb.HashDB[H, []byte],
	root H,
	delta []struct {
		Key   []byte
		Value []byte
	},
	recorder triedb.TrieRecorder,
	cache cache.TrieCache,
	stateVersion storage.StateVersion,
) (H, error) {
	// trie := triedb.NewTrieDBMutBuilderFromExisting[TrieHash](db, root).Build()
	trieDB := triedb.NewTrieDB[H, Hasher](root, wrapper.New[H, Hasher](db), triedb.WithCache[H, Hasher](cache), triedb.WithRecorder[H, Hasher](recorder))
	switch stateVersion {
	case storage.StateVersionV0:
	case storage.StateVersionV1:
		trieDB.SetVersion(trie.V1)
	}

	slices.SortStableFunc(delta, func(a struct {
		Key   []byte
		Value []byte
	}, b struct {
		Key   []byte
		Value []byte
	}) int {
		if string(a.Key) < string(b.Key) {
			return -1
		} else if string(a.Key) == string(b.Key) {
			return 0
		} else {
			return 1
		}
	})

	for _, kv := range delta {
		if kv.Value != nil {
			err := trieDB.Put(kv.Key, kv.Value)
			if err != nil {
				return *(new(H)), err
			}
		} else {
			err := trieDB.Delete(kv.Key)
			if err != nil {
				return *(new(H)), err
			}
		}
	}

	return trieDB.Hash()
}

// / Read a value from the trie.
func ReadTrieValue[H runtime.Hash, Hasher runtime.Hasher[H]](
	db hashdb.HashDB[H, []byte],
	root H,
	key []byte,
	recorder triedb.TrieRecorder,
	cache cache.TrieCache,
) ([]byte, error) {
	trieDB := triedb.NewTrieDB[H, Hasher](root, wrapper.New[H, Hasher](db), triedb.WithCache[H, Hasher](cache), triedb.WithRecorder[H, Hasher](recorder))
	trieDB.SetVersion(trie.V1)
	// TODO: modify triedb to return error on `Get`
	return trieDB.Get(key), nil
}

type KeySpacedDB[Hash comparable, T any] struct {
	DB     hashdb.HashDB[Hash, T]
	Prefix []byte
}

func NewKeySpacedDB[Hash comparable, T any](db hashdb.HashDB[Hash, T], ks []byte) *KeySpacedDB[Hash, T] {
	return &KeySpacedDB[Hash, T]{
		DB:     db,
		Prefix: ks,
	}
}

func (tbe *KeySpacedDB[H, T]) Get(key H, prefix hashdb.Prefix) *T {
	panic("unimpl")
}

func (tbe *KeySpacedDB[H, T]) Contains(key H, prefix hashdb.Prefix) bool {
	return tbe.Get(key, prefix) != nil
}

func (tbe *KeySpacedDB[H, T]) Insert(prefix hashdb.Prefix, value []byte) H {
	panic("unimplemented")
}

func (tbe *KeySpacedDB[H, T]) Emplace(key H, prefix hashdb.Prefix, value T) {
	panic("unimplemented")
}

func (tbe *KeySpacedDB[H, T]) Remove(key H, prefix hashdb.Prefix) {
	panic("unimplemented")
}
